<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Grade Calculator</title>
    <link rel="stylesheet" href="./style/grades.css">
    <link rel="stylesheet" href="./style/style.css">
    <link rel="shortcut icon" href="./assets/calc.png" type="image/x-icon">
</head>
<body>
    <header>
        <h1 class="space-mono-bold">
            Student's Web Tools
        </h1>
        <nav>
            <a href="./grades.html" class="image-link"><img src="./assets/calc.png" alt="" srcset=""></a>
            <a href="./index.html" class="image-link"><img src="./assets/home.png" alt="" srcset=""></a>
            <a href="" class="image-link"><img src="./assets/gear.png" alt="" srcset="" id="config"></a>
        </nav>
    </header>
    <div id="alert-center"></div>
    <div id="query-bg">
        <div id="query">

        </div>
    </div>
    <div id="report">
        <h1 class="space-mono-bold">Final Report</h1>
        <div id="progress-bar">[--------------------]</div><br>
        <a href="" class="text-button" id="reportGen">Generate Report</a><br><br>
        <label for="">Maximum Grade: </label><input value="0" type="number" onchange="updateSettings()" id="max_grade"><br>
        <label for="">Passing Grade: </label><input value="0" type="number" id="passing_grade" onchange="updateSettings()">
        <div id="weights"></div>
    </div>
    <div id="canvas">

    </div>
    <script defer>
        // Not optimized for phone
        if (navigator.userAgentData && navigator.userAgentData.mobile){
            alert("Phone view is not recommended for this site.");
        }
    
        let info = [];
        let gradeInfo = {
            "max_grade":5,
            "passing_grade":3
        };
        let windowInfo = {
            "title":"",
            "content":[],
            "pos":[],
            "size":[],
            "elem":undefined,
            "weight":0
        };
        let automaticRecover = false;

        let canvas = document.getElementById("canvas");

        function loadSettings(){
            if (localStorage.getItem("gradeInfo") == undefined){
                localStorage.setItem("gradeInfo", JSON.stringify(gradeInfo));
            }else{
                gradeInfo = JSON.parse(localStorage.getItem("gradeInfo"));
            }
            document.getElementById("max_grade").value = gradeInfo.max_grade;
            document.getElementById("passing_grade").value = gradeInfo.passing_grade;
        }
        loadSettings();

        function updateSettings(){
            document.getElementById("max_grade").value = +document.getElementById("max_grade").value;
            document.getElementById("passing_grade").value = +document.getElementById("passing_grade").value;
            gradeInfo.max_grade = +document.getElementById("max_grade").value;
            gradeInfo.passing_grade = +document.getElementById("passing_grade").value;
            localStorage.setItem("gradeInfo", JSON.stringify(gradeInfo));
            updateReport();
        }

        function pureRecover(){
            // Recovering data
            recovery_info = JSON.parse(localStorage.getItem("gradeData"));
            for (let i = 0; i < recovery_info.length; i++){
                if (recovery_info[i] == null){
                    return;
                }
                if (createWindow(recovery_info[i].title, recovery_info[i].weight, recovery_info[i].pos) == -1){
                    raiseError("Error!", "Error recovering previous session!");
                    return;
                }
                let newWind = getIndexName(recovery_info[i].title);
                if (newWind == -1){
                    continue;
                }
                newWind = info[newWind];
                newWind.content = recovery_info[i].content;
                dataHolder = newWind.elem.getElementsByTagName("div")[0].getElementsByTagName("div")[0];
                dataHolder.innerText = recovery_info[i].content.join("\n");
                if (dataHolder.innerText != ""){
                    dataHolder.innerText+="\n";
                }
                newWind.elem.getElementsByTagName("input")[0].onauxclick();
                newWind.elem.style.width = recovery_info[i].size[0] + "px";
                newWind.elem.style.height = dataHolder.offsetHeight;
            }
            document.getElementById("query-bg").style.display = "none"; //Testing
            updateReport();
        }

        function recoverData(){
            if (localStorage.getItem("restoreJam")){
                return;
            }
            if (localStorage.getItem("gradeData") == undefined){
                updateReport();
            }else{
                if (localStorage.getItem("automaticRecover") != undefined){
                    automaticRecover = JSON.parse(localStorage.getItem("automaticRecover"));
                }
                if (automaticRecover){
                    raiseInfo("Automatic Recovery On", "Data is being recovered into position!")
                    pureRecover();
                }else{
                    raiseWarning("Saved Data Found!", "Type 'yes' in the prompt to recover old data! Or type 'YES' to activate automatic recovery!");
                    getInfo(["Type 'yes' to recover data"], (data)=>{
                        if (data.length < 1){
                            raiseError("System Error!", "Function did not recieve enough arguments!");
                            return;
                        }
                        if (data[0] == "YES"){
                            automaticRecover = true;
                            localStorage.setItem("automaticRecover", JSON.stringify(automaticRecover));
                            pureRecover();
                        }
                        if (data[0] != "yes"){
                            return;
                        }
                        pureRecover();
                    });
                }
            }
        }

        recoverData();

        let mousePos = [0, 0];
        let ticksDragged = 0;
        document.body.onmousemove = (e)=>{
            if (clicking){
                ticksDragged = ticksDragged + 1;
            }
            mousePos[0] = e.clientX - canvas.offsetLeft;
            mousePos[1] = e.clientY - canvas.offsetTop;
        }
        let clicking = false;
        document.body.onmousedown = (e)=>{
            ticksDragged = 0;
            clicking = true;
        }

        document.body.onmouseup = (e)=>{
            clicking = false;
        }

        function getIndexName(name){
            let pos = 0;
            while (pos < info.length){
                if (info[pos].title == name){
                    return pos;
                }
                pos = pos + 1;
            }
            return -1;
        }

        function deleteWindow(name){
            getInfo([`Type "${name}" to delete!`], (data)=>{
                if (data.length < 1){
                    raiseError("System Error!", "Didn't receive the information!");
                    return;
                }
                if (data[0] != name){
                    raiseWarning("Name Error!", "You typed the wrong name!");
                    return;
                }
                document.getElementById("query-bg").style.display = "none";
                let index = getIndexName(name);
                if (index != -1){
                    canvas.removeChild(info[index].elem);
                    info.splice(index, 1);
                    console.log(info);
                }
                updateReport();
            })
        }

        function createWindow(name, weight, pos){
            if (getIndexName(name) != -1){
                return -1;
            }
            let newWindow = document.createElement("div");
            newWindow.classList.add("window");

            if (pos == undefined){
                newWindow.style.top = mousePos[1] + "px";
                newWindow.style.left = mousePos[0] + "px";
                pos = mousePos;
            }else{
                newWindow.style.top = pos[1] + "px";
                newWindow.style.left = pos[0] + "px";
            }

            let windowHead = document.createElement("nav");
            let windowTitle = document.createElement("p");
            windowTitle.innerText = name;
            let windowClose = document.createElement("button");
            windowClose.innerText = "X";
            windowClose.classList.add("text-button");
            windowClose.onclick = ()=>{
                deleteWindow(name);
            }
            windowHead.appendChild(windowTitle);
            windowHead.appendChild(windowClose);
            newWindow.appendChild(windowHead);

            // INFORMATION UPLOAD
            let information = { ...windowInfo };
            information.title = name;
            information.weight = weight;
            information.pos = pos;
            information.elem = newWindow;
            information.content = [];

            let content = document.createElement("div");
            content.classList.add("windowContent");
            let magicOut = document.createElement("div");
            let magicOF = document.createElement("div"); // overflow
            let magicInput = document.createElement("input");
            magicInput.type = "number";
            magicInput.placeholder = "+ Add Grade"
            let magicIndex = 0;
            magicInput.onauxclick = ()=>{
                magicIndex = magicOut.innerText.split("\n").length-1;
                console.log(magicIndex);
            }
            magicInput.onchange = ()=>{
                if (magicInput.value == ""){
                    // UP ARROW
                    let last_line = magicOut.innerText.split("\n");
                    if (last_line.length < 2){
                        return;
                    }
                    let newMagicOut = "";
                    for (let i = 0; i < last_line.length-2; i++){
                        newMagicOut = newMagicOut + last_line[i].toString() + "\n";
                    }
                    last_line = last_line[last_line.length-2];
                    magicOut.innerText = newMagicOut;
                    if (magicInput.value != ""){
                        magicOF.innerText = magicInput.value + "\n" + magicOF.innerText;
                    }
                    magicInput.value = last_line;
                    information.content.splice(magicIndex, 1);
                    updateReport();
                    return;
                }
                if (+magicInput.value > gradeInfo.max_grade){
                    magicInput.value = gradeInfo.max_grade;
                }
                magicIndex = magicIndex + 1;
                information.content.splice(magicIndex, magicIndex == information.content.length ? 0 : 1, +magicInput.value);
                magicOut.innerText = magicOut.innerText + magicInput.value + "\n";
                let splitted_text = magicOF.innerText.split("\n");
                magicInput.value = splitted_text[0];
                let newOF = "";
                for (let i = 1; i < splitted_text.length; i++){
                    if (splitted_text[i] == ""){
                        continue;
                    }
                    newOF = newOF + splitted_text[i] + "\n";
                }
                magicOF.innerText = newOF;
                newWindow.style.height = content.style.height;
                information.size[1] = newWindow.style.height;
                updateReport();
            }
            magicInput.onkeydown = (e)=>{
                if (e.keyCode == 38 || e.keyCode == 40) {
                    e.preventDefault()
                }
                if (e.keyCode == 38){
                    // UP ARROW
                    let last_line = magicOut.innerText.split("\n");
                    if (last_line.length < 2){
                        return;
                    }
                    if (magicInput.value == ""){
                        information.content.splice(magicIndex, 1);
                        updateReport();
                    }else{
                        if (+magicInput.value > gradeInfo.max_grade){
                            magicInput.value = gradeInfo.max_grade;
                            information.content[magicIndex] = +magicInput.value;
                            updateReport();
                        }
                    }
                    magicIndex = magicIndex - 1;
                    let newMagicOut = "";
                    for (let i = 0; i < last_line.length-2; i++){
                        newMagicOut = newMagicOut + last_line[i].toString() + "\n";
                    }
                    last_line = last_line[last_line.length-2];
                    magicOut.innerText = newMagicOut;
                    if (magicInput.value != ""){
                        magicOF.innerText = magicInput.value + "\n" + magicOF.innerText;
                    }
                    magicInput.value = last_line;
                }
                if (e.keyCode == 40){
                    // DOWN ARROW
                    if (magicInput.value == ""){
                        return;
                    }else{
                        if (+magicInput.value > gradeInfo.max_grade){
                            magicInput.value = gradeInfo.max_grade;
                            information.content[magicIndex] = +magicInput.value;
                            updateReport();
                        }
                    }
                    magicIndex = magicIndex + 1;
                    magicOut.innerText = magicOut.innerText + magicInput.value + "\n";
                    let splitted_text = magicOF.innerText.split("\n");
                    magicInput.value = splitted_text[0];
                    let newOF = "";
                    for (let i = 1; i < splitted_text.length; i++){
                        if (splitted_text[i] == ""){
                            continue;
                        }
                        newOF = newOF + splitted_text[i] + "\n";
                    }
                    magicOF.innerText = newOF;
                }
            }
            content.appendChild(magicOut);
            content.appendChild(magicInput);
            content.appendChild(magicOF);
            content.onclick = (e)=>{e.stopPropagation()}
            content.onmousedown = (e)=>{e.stopPropagation()}
            newWindow.appendChild(content);


            newWindow.onclick = (e)=>{e.stopPropagation();}
            let offsetX = 0;
            let offsetY = 0;
            let startX = 0;
            let startY = 0;

            let moving = false;
            let changeWidth = false;
            let changeHeight = false;
            let relativePos = [0, 0];
            newWindow.onmousedown = (e)=>{
                if (relativePos[1] + 100 >= e.clientY){
                    offsetX = e.clientX;
                    offsetY = e.clientY;
                    startX = newWindow.style.left;
                    startX = +(startX.substr(0, startX.length - 2));
                    startY = newWindow.style.top;
                    startY = +(startY.substr(0, startY.length - 2));
                    moving = true;
                    return;
                }
                if (relativePos[0]+newWindow.offsetWidth-50 <= e.clientX){
                    changeWidth = true;
                    offsetX = mousePos[0];
                    startX = newWindow.offsetWidth;
                }
                if (relativePos[1]+newWindow.offsetHeight-50 <= mousePos[1]){
                    changeHeight = true;
                    offsetY = mousePos[1];
                    startY = newWindow.offsetHeight;
                }
            }
            newWindow.onmouseup = ()=>{
                moving = false;
                changeWidth = false;
                changeHeight = false;
            }
            newWindow.onmouseleave = newWindow.onmouseup;
            newWindow.onmousemove = (e)=>{
                if (moving){
                    let newLeft = (startX + (e.clientX - offsetX));
                    newLeft = newLeft < 0 ? 0 : newLeft;
                    newLeft = newLeft > canvas.offsetWidth-newWindow.offsetWidth ? canvas.offsetWidth-newWindow.offsetWidth : newLeft;
                    let newTop = (startY + (e.clientY - offsetY));
                    newTop = newTop < 0 ? 0 : newTop;
                    newTop = newTop > canvas.offsetHeight-newWindow.offsetHeight ? canvas.offsetHeight-newWindow.offsetHeight : newTop;
                    newWindow.style.left = newLeft + "px";
                    newWindow.style.top = newTop + "px";
                    information.pos = [newLeft, newTop];
                }
                if (changeWidth){
                    let newWidth = (startX + (mousePos[0] - offsetX));
                    newWidth = newWidth < 150 ? 150 : newWidth;
                    newWindow.style.width = newWidth + "px";
                    information.size[0] = newWidth;
                }
                if (changeHeight){
                    let newHeight = (startY + (mousePos[1] - offsetY));
                    newHeight = newHeight < 75 ? 75 : newHeight;
                    newWindow.style.height = newHeight + "px";
                    content.style.height = (newHeight * 0.75) + "px";
                    information.size[1] = newHeight;
                }
                relativePos = [newWindow.offsetLeft, newWindow.offsetTop]
                updateReport();
            }
            canvas.appendChild(newWindow);
            magicInput.focus();
            information.size = [newWindow.offsetWidth, newWindow.offsetHeight];
            info.push(information);
            return 0;
        }

        function getInfo(requested, outFunc){
            let query = document.getElementById("query");
            query.innerHTML = "";

            query.onclick = (e)=>{e.stopPropagation()}

            for (let i = 0; i < requested.length; i++){
                let element = requested[i];
                let input = document.createElement("input");
                input.type = "text";
                input.placeholder = element;
                query.appendChild(input);
            }

            let submit = document.createElement("button");
            let bg = document.getElementById("query-bg");

            submit.onclick = ()=>{
                let data = [];
                let queries = query.getElementsByTagName("input");
                for(let i = 0; i < queries.length; i++){
                    let element = queries[i];
                    if (element.value == "") {
                        raiseWarning("Query Values", "All Query values must be filled!");
                        return;
                    }
                    data.push(element.value);
                }
                outFunc(data);
            }

            let entries = query.getElementsByTagName("input");
            for (let i = 0; i < entries.length-1; i++){
                let elem = entries[i];
                entries[i].onchange = ()=>{entries[i+1].focus()}
            }
            entries[entries.length - 1].onchange = submit.onclick;

            submit.innerText = "Submit"
            query.appendChild(submit);
            bg.style.display = "flex";
            bg.onclick = ()=>{bg.style.display = "none"}
            query.getElementsByTagName("input")[0].focus()
        }

        function processWindow(data){
            if (data.length < 2){
                raiseError("System Error!", "Function was passed too few arguments!");
                return;
            }
            if (data[0].length > 15){
                raiseError("Error!", "Assignment name too long!");
                return;
            }
            if (isNaN(+data[1])){
                raiseError("Error!", "Assignment weight must be number!");
                return;
            }
            if (createWindow(data[0], +data[1], undefined) == -1){
                raiseError("Error!", "Assignment name already taken!");
                return;
            }
            document.getElementById("query-bg").style.display = "none";
            updateReport()
        }

        function updateReport(){
            let out = "Log:\n";
            let total = 0;
            let outGrade = 0;
            out = out + "Calculated Weight of Assignments:\n";
            info.forEach(element => {
                let localGrade = 0;
                out = `${out}${element.title} -> ${element.weight}%\n`
                element.content.forEach(elem=>{
                    elem = elem < 0 ? 0 : elem;
                    elem = elem > gradeInfo.max_grade ? gradeInfo.max_grade : elem;
                    localGrade = localGrade + elem;
                    out = `${out}Added grade: ${elem}\n`;
                })
                localGrade = localGrade/element.content.length;
                out = `${out}Local Grade: ${localGrade}\n`;
                outGrade = outGrade + localGrade*(element.weight/100);
                total = total + element.weight;
            });
            outGrade = isNaN(outGrade) ? 0 : outGrade;
            out = `${out}Calculated Grade: ${outGrade}\n`;
            if (total < 100){
                out = `${out}Weight Auto Filled -> ${100-total}%\n`
            }
            outGrade = (outGrade * 100)/total;
            outGrade = isNaN(outGrade) ? 0 : outGrade;
            out = `${out}Grade After Rule of 3rds: ${outGrade}\n`;
            out = `${out}${outGrade}`;
            if (outGrade >= gradeInfo.passing_grade){
                out = `${out} is a passing grade!\n`
            }else{
                out = `${out} is not a passing grade\n`
            }
            out = `${out} saving report...\n`
            localStorage.setItem("gradeData", JSON.stringify(info));
            out = `${out} report saved!\n`;
            document.getElementById("weights").innerText = out;
            let pb = document.getElementById("progress-bar");
            let outProgress = "[";
            let perc = (outGrade/gradeInfo.max_grade)*20;
            for (let i = 0; i < perc; i++){
                outProgress = outProgress + "X";
            }
            let antiPerc = 20-perc;
            for (let i = 0; i < antiPerc; i++){
                outProgress = outProgress + "-";
            }
            outProgress = outProgress + `] ${Math.floor(outGrade*100)/100}/${gradeInfo.max_grade}`
            pb.innerText = outProgress;
            let reportGen = document.getElementById("reportGen");
            reportGen.innerText = "Generate Report";
            reportGen.href = "";
            reportGen.removeAttribute("download")
            reportGen.onclick = (e)=>{
                e.preventDefault();
                createReport();
                reportGen.onclick = ()=>{}
            }
            
        }

        function fillAlertText(title, text){
            let centre = document.getElementById("alert-center");
            centre.innerHTML = "";

            let titleHandle = document.createElement("h1");
            let textHandle = document.createElement("p");
            titleHandle.innerText = title;
            textHandle.innerText = text;

            centre.appendChild(titleHandle);
            centre.appendChild(textHandle);
        }

        function raiseWarning(errorTitle, errorText){
            let centre = document.getElementById("alert-center");
            centre.classList.add("warning");
            fillAlertText(errorTitle, errorText);
            setTimeout(()=>{centre.classList.remove("warning")}, 1500);
        }

        function raiseError(errorTitle, errorText){
            let centre = document.getElementById("alert-center");
            centre.classList.add("error");
            fillAlertText(errorTitle, errorText);
            setTimeout(()=>{centre.classList.remove("error")}, 1500);
        }

        function raiseInfo(infoTitle, infoText){
            let centre = document.getElementById("alert-center");
            centre.classList.add("info");
            fillAlertText(infoTitle, infoText);
            setTimeout(()=>{centre.classList.remove("info")}, 1500);
        }

        function createReport(){
            var reportCanvas = document.createElement("canvas");
            let reportGen = document.getElementById("reportGen");
            reportGen.innerText = "Generating Report...";

            reportCanvas.width = 800;
            reportCanvas.height = 10000;

            var ctx = reportCanvas.getContext("2d");
            ctx.beginPath();

            // Background
            ctx.rect(0, 0, reportCanvas.width, reportCanvas.height);
            ctx.fillStyle = "snow";
            ctx.fill();

            // Text
            ctx.font = "bold 48px 'Space Mono', monospace";
            ctx.fillStyle = "black";
            let metrics = ctx.measureText("Grade Report");
            let height = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;
            ctx.fillText("Grade Report", 15, height);

            let currHeight = height;
            ctx.font = "24px 'Space Mono', monospace";
            metrics = ctx.measureText("Grade by Weight:");
            height = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent + 15;
            currHeight += height;
            ctx.fillText("Grade by Weight:", 25, currHeight);

            let gradeHeight = 0;
            let gradeMetrics = `Max Grade: ${gradeInfo.max_grade}`;
            metrics = ctx.measureText(gradeMetrics);
            height = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent + 5;
            gradeHeight+=height;
            ctx.fillText(gradeMetrics, reportCanvas.width - 10 - metrics.width, height);
            gradeMetrics = `Passing Grade: ${gradeInfo.passing_grade}`;
            metrics = ctx.measureText(gradeMetrics);
            height = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent + 5;
            gradeHeight+=height;
            ctx.fillText(gradeMetrics, reportCanvas.width - 10 - metrics.width, gradeHeight);

            ctx.font = "bold 20px 'Space Mono', monospace";

            let percAdd = 0;
            let finalGrade = 0;

            info.forEach(elem=>{
                let sectionHeight = 0;
                let maxWidth = reportCanvas.width-50;
                let titleText = `${elem.title} - ${elem.weight}%`;
                metrics = ctx.measureText(titleText);
                height = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent + 15;
                currHeight+=height;
                ctx.fillText(titleText, 30, currHeight);
                let calc = 0;
                percAdd+=elem.weight;
                elem.content.forEach(element=>{
                    let text = `${element}`;
                    metrics = ctx.measureText(text);
                    height = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent + 10;
                    calc += element;
                    sectionHeight += height;
                    ctx.fillText(text, 30, currHeight+sectionHeight);
                })
                ctx.strokeRect(25, currHeight+5, maxWidth+5, sectionHeight);
                currHeight+=sectionHeight;
                calc /= elem.content.length;
                calc *= elem.weight/100;
                finalGrade += calc;
                let text = `Calculated Segment: ${Math.floor(calc*100)/100}`;
                metrics = ctx.measureText(text);
                height = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent + 10;
                currHeight+=height;
                ctx.fillText(text, 30, currHeight);
            })
            
            currHeight+=5;
            ctx.strokeRect(10, currHeight, reportCanvas.width-20, 1);

            if (percAdd < 100){
                let text = `Missing ${100-percAdd}%`;
                metrics = ctx.measureText(text);
                height = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent + 10;
                currHeight+=height;
                ctx.fillText(text, 30, currHeight);
                finalGrade = (finalGrade*100)/percAdd;
            }

            let text = `Final Grade: ${Math.floor(finalGrade*100)/100}`;
            metrics = ctx.measureText(text);
            height = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent + 10;
            currHeight+=height;
            ctx.fillText(text, 30, currHeight);
            
            // Stamp
            let stampCanvas = document.createElement("canvas");
            stampCanvas.width = 180;
            stampCanvas.height = 180;
            let stampCtx = stampCanvas.getContext("2d");

            let finalScore = finalGrade >= gradeInfo.passing_grade ? "passed" : "failed";
            stampCtx.beginPath();
            stampCtx.fillStyle = finalScore == "passed" ? "green" : "red";
            finalScore = finalScore.toUpperCase();
            stampCtx.arc(90, 90, 80, 0, 2 * Math.PI);
            stampCtx.fill();

            stampCtx.globalCompositeOperation = "destination-out";
            stampCtx.beginPath();
            stampCtx.arc(90, 90, 65, 0, 2 * Math.PI);
            stampCtx.fill();
            stampCtx.fillRect(0, 70, stampCanvas.width, 40);
            stampCtx.globalCompositeOperation = "source-over";
            stampCtx.beginPath();
            stampCtx.arc(90, 90, 60, 0, 2*Math.PI);
            stampCtx.fill();
            stampCtx.fillRect(0, 75, stampCanvas.width, 30);
            stampCtx.globalCompositeOperation = "destination-out";
            stampCtx.fillRect(0, 70, stampCanvas.width, 5);
            stampCtx.fillRect(0, 105, stampCanvas.width, 5);

            stampCtx.font = "bold 30px 'Pirata One', serif";
            metrics = stampCtx.measureText(finalScore);
            height = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;
            stampCtx.fillText(finalScore, (stampCanvas.width-metrics.width)/2, (stampCanvas.height+height)/2);

            ctx.globalAlpha = 0.4;
            ctx.save();
            const rotAngle = Math.random() * (Math.PI/2) - Math.PI/4;
            const dx = Math.floor(Math.random()*(reportCanvas.width - stampCanvas.width));
            const dy = Math.floor(Math.random()*(currHeight - stampCanvas.height));
            ctx.translate(dx + stampCanvas.width / 2, dy + stampCanvas.height / 2);
            ctx.rotate(rotAngle);
            ctx.drawImage(stampCanvas, -stampCanvas.width / 2, -stampCanvas.height / 2 );
            ctx.restore();

            // Fixing canvas size
            let outCanvas = document.createElement("canvas");
            outCanvas.width = reportCanvas.width;
            outCanvas.height = currHeight + 20;
            outCanvas.getContext("2d").drawImage(reportCanvas, 0, 0);

            let reportUrl = outCanvas.toDataURL();
            reportGen.download = "report.png";
            reportGen.innerText = "Download Report";
            reportGen.href = reportUrl;
        }

        canvas.onclick = ()=>{
            if (ticksDragged > 10) return;
            getInfo(["Assignment Name", "Assignment Weight"], processWindow);
        };

        document.getElementById("config").onclick = (e)=>{
            raiseInfo("Stop trying to recover!", "If you type 'no' in the prompt you will stop recovering completely! And 'clear' will empty your data stored!")
            getInfo([`Type 'yes' to ${automaticRecover ? "stop using automatic recover" : "start using automatic recover"}`], (data)=>{
                if (data.length < 1){
                    raiseError("System Error!", "Not enough arguments were passed!");
                }
                if (data[0] == "yes"){
                    if (localStorage.getItem("restoreJam")){
                        localStorage.removeItem("restoreJam");
                        automaticRecover = false;
                    }
                    automaticRecover = !automaticRecover;
                    localStorage.setItem("automaticRecover", JSON.stringify(automaticRecover));
                    raiseInfo("Automatic Recover", `Automatic Recover is now set to ${automaticRecover}`);
                }
                if (data[0] == "no"){
                    localStorage.setItem("restoreJam", "hello, world!");
                    raiseInfo("No backup!", "Since you disabled recover you will have no backup!");
                }
                if (data[0]=="clear"){
                    localStorage.clear();
                }
                document.getElementById("query-bg").style.display = "none";
            })
            e.preventDefault();
        }
    </script>
</body>
</html>